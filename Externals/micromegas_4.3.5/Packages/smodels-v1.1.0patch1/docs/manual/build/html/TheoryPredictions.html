

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Theory Predictions &mdash; SModelS 1.1.0patch1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="SModelS 1.1.0patch1 documentation" href="index.html"/>
        <link rel="up" title="SModelS Structure" href="Structure.html"/>
        <link rel="next" title="Database of Experimental Results" href="DatabaseStructure.html"/>
        <link rel="prev" title="Decomposition into Simplified Models" href="Decomposition.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> SModelS
          

          
          </a>

          
            
            
              <div class="version">
                1.1.0patch1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ReleaseUpdate.html">What&#8217;s New in Version 1.1</a></li>
<li class="toctree-l1"><a class="reference internal" href="Installation.html">Installation and Deployment</a></li>
<li class="toctree-l1"><a class="reference internal" href="RunningSModelS.html">Using SModelS</a></li>
<li class="toctree-l1"><a class="reference internal" href="Tools.html">SModelS Tools</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="SModelsDocs.html">Detailed Guide to SModelS</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="SModelSDefs.html">Basic Concepts and Definitions</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="Structure.html">SModelS Structure</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="BasicInput.html">Basic Input</a></li>
<li class="toctree-l3"><a class="reference internal" href="Decomposition.html">Decomposition into Simplified Models</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="">Theory Predictions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#computing-theory-predictions">Computing Theory Predictions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#theory-predictions-for-upper-limit-results">Theory Predictions for Upper Limit Results</a></li>
<li class="toctree-l4"><a class="reference internal" href="#theory-predictions-for-efficiency-map-results">Theory Predictions for Efficiency Map Results</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="DatabaseStructure.html">Database of Experimental Results</a></li>
<li class="toctree-l3"><a class="reference internal" href="ConfrontPredictions.html">Confronting Predictions with Experimental Limits</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="OutputDescription.html">Output Description</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Examples.html">How To&#8217;s</a></li>
<li class="toctree-l1"><a class="reference internal" href="CodeDocs.html">SModelS Code Documentation</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">SModelS</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
          <li><a href="SModelsDocs.html">Detailed Guide to SModelS</a> &raquo;</li>
      
          <li><a href="Structure.html">SModelS Structure</a> &raquo;</li>
      
    <li>Theory Predictions</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/TheoryPredictions.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <span class="target" id="index-0"></span><div class="section" id="theory-predictions">
<span id="theorypredictions"></span><h1>Theory Predictions<a class="headerlink" href="#theory-predictions" title="Permalink to this headline">¶</a></h1>
<p>The <a class="reference internal" href="Decomposition.html"><em>decomposition</em></a> of the input model as a sum of <a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a>
(simplified models) is the
first step for confronting the model with the experimental limits.
The next step consists of computing the relevant signal cross sections
(or <em>theory predictions</em>) for comparison with the experimental limits. Below we describe the procedure
for the computation of the theory predictions after the model has been decomposed.</p>
<div class="section" id="computing-theory-predictions">
<h2>Computing Theory Predictions<a class="headerlink" href="#computing-theory-predictions" title="Permalink to this headline">¶</a></h2>
<p>As discussed in <a class="reference internal" href="DatabaseDefinitions.html"><em>Database Definitions</em></a>, the SModelS  database allows
for two types of experimental constraints:
Upper Limit constraints   (see <a class="reference internal" href="DatabaseDefinitions.html#ultype"><span>UL-type results</span></a>) and Efficiency Map constraints (see <a class="reference internal" href="DatabaseDefinitions.html#emtype"><span>EM-type results</span></a>).
Each of them requires different theoretical predictions to be compared against experimental data.</p>
<p><a class="reference internal" href="DatabaseDefinitions.html#ultype"><span>UL-type results</span></a> constrains the weight (<span class="math">\(\sigma \times BR\)</span>) of one <a class="reference internal" href="TheoryDefinitions.html#element"><span>element</span></a> or sum of <a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a>.
Therefore SModelS must compute the theoretical value of <span class="math">\(\sigma \times BR\)</span> summing only over the <a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a>
appearing in the respective <a class="reference internal" href="DatabaseDefinitions.html#ulconstraint"><span>constraint</span></a>.
This is done applying a 1 (zero) efficiency (<span class="math">\(\epsilon\)</span>) for the
elements which appear (do not appear) in the <a class="reference internal" href="DatabaseDefinitions.html#ulconstraint"><span>constraint</span></a>.
Then the final theoretical prediction is the sum over all
<a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a> with a non-zero value of <span class="math">\(\sum \sigma \times BR \times \epsilon\)</span>. This value can then be compared with the
respective 95% C.L. upper limit extracted from the UL map (see <a class="reference internal" href="DatabaseDefinitions.html#ultype"><span>UL-type results</span></a>).</p>
<p>On the other hand, <a class="reference internal" href="DatabaseDefinitions.html#emtype"><span>EM-type results</span></a> constrain the total signal (<span class="math">\(\sum \sigma \times BR \times \epsilon\)</span>) in a given signal region (<a class="reference internal" href="DatabaseDefinitions.html#dataset"><span>DataSet</span></a>).
Consequently, in this case SModelS must compute <span class="math">\(\sigma \times BR \times \epsilon\)</span> for each <a class="reference internal" href="TheoryDefinitions.html#element"><span>element</span></a>, using the efficiency maps for
the corresponding <a class="reference internal" href="DatabaseDefinitions.html#dataset"><span>DataSet</span></a>. The final theoretical prediction is the sum over all <a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a>
with a non-zero value of <span class="math">\(\sigma \times BR \times \epsilon\)</span>.
This value can then be compared with the signal upper limit for the respective
signal region (<a class="reference internal" href="DatabaseDefinitions.html#dataset"><span>data set</span></a>).</p>
<p>Although the details of the theoretical prediction computation differ depending on the type
of <a class="reference internal" href="DatabaseDefinitions.html#expresult"><span>Experimental Result</span></a> (<a class="reference internal" href="DatabaseDefinitions.html#ultype"><span>UL-type results</span></a> or <a class="reference internal" href="DatabaseDefinitions.html#emtype"><span>EM-type results</span></a>), the overall procedure is common for both type of results. Below we schematically
show the main steps of the theory prediction calculation:</p>
<a class="reference internal image-reference" href="_images/theoryPredScheme.png"><img alt="_images/theoryPredScheme.png" src="_images/theoryPredScheme.png" style="width: 90%;" /></a>
<p>As shown above the procedure can always be divided in two main steps:
<em>Element Selection</em> and <em>Element Clustering</em>.
Once the <a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a> have been selected and clustered, the theory prediction for each <a class="reference internal" href="DatabaseDefinitions.html#dataset"><span>DataSet</span></a> is given by
the sum of all the <a class="reference internal" href="TheoryDefinitions.html#element"><span>element</span></a> weights (<span class="math">\(\sigma \times BR \times \epsilon\)</span>) belonging to the same cluster:</p>
<div class="math">
\[\mbox{theory prediction } = \sum_{cluster} (\mbox{element weight}) =  \sum_{cluster} (\sigma \times BR \times \epsilon)\]</div>
<p>Below we describe in detail the <em>element selection</em> and <em>element clustering</em>
methods for computing the theory predictions for each type
of <a class="reference internal" href="DatabaseDefinitions.html#expresult"><span>Experimental Result</span></a> separately.</p>
<ul class="simple">
<li><strong>Theory predictions are computed using the</strong> <a class="reference external" href="../../../documentation/build/html/theory.html#theory.theoryPrediction.theoryPredictionsFor">theoryPredictionsFor</a> <strong>method</strong></li>
</ul>
</div>
<div class="section" id="theory-predictions-for-upper-limit-results">
<span id="thepredul"></span><h2>Theory Predictions for Upper Limit Results<a class="headerlink" href="#theory-predictions-for-upper-limit-results" title="Permalink to this headline">¶</a></h2>
<p>Computation of the signal cross sections for a given
<a class="reference internal" href="DatabaseDefinitions.html#ultype"><span>UL-type result</span></a> takes place in two steps. First selection of the
<a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a> generated by the model <a class="reference internal" href="Decomposition.html"><em>decomposition</em></a> and then clustering
of the selected elements according to their masses. These two steps are described below.</p>
<div class="section" id="element-selection">
<span id="ulselection"></span><h3>Element Selection<a class="headerlink" href="#element-selection" title="Permalink to this headline">¶</a></h3>
<p>An <a class="reference internal" href="DatabaseDefinitions.html#ultype"><span>UL-type result</span></a> holds upper limits for the cross sections of an <a class="reference internal" href="TheoryDefinitions.html#element"><span>element</span></a>
or sum of <a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a>. Consequently, the first step for computing the theory predictions for the corresponding
experimental result is to select the <a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a> that appear in the <a class="reference internal" href="DatabaseDefinitions.html#ulconstraint"><span>UL result constraint</span></a>.
This is conveniently done attributing to each <a class="reference internal" href="TheoryDefinitions.html#element"><span>element</span></a> an efficiency equal to 1 (0)
if the <a class="reference internal" href="TheoryDefinitions.html#element"><span>element</span></a> appears (does not appear) in the <a class="reference internal" href="DatabaseDefinitions.html#ulconstraint"><span>constraint</span></a>.
After all the <a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a> weights (<span class="math">\(\sigma \times BR\)</span>) have been rescaled
by these &#8216;&#8217;trivial&#8217;&#8217; efficiencies, only the ones with non-zero weights are relevant for the signal
cross section.
The <a class="reference internal" href="TheoryDefinitions.html#element"><span>element</span></a> selection is then trivially achieved by selecting all the <a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a> with non-zero weights.</p>
<p>The procedure described above is illustrated graphically in the figure below for the simple example where the
<a class="reference internal" href="DatabaseDefinitions.html#ulconstraint"><span>constraint</span></a> is <span class="math">\([[[e^+]],[[e^-]]]\,+\,[[[\mu^+]],[[\mu^-]]]\)</span>.</p>
<a class="reference internal image-reference" href="_images/ULselection.png"><img alt="_images/ULselection.png" src="_images/ULselection.png" style="width: 85%;" /></a>
<ul class="simple">
<li><strong>The element selection is implemented by the</strong> <a class="reference external" href="../../../documentation/build/html/theory.html#theoryPrediction._getElementsFrom">getElementsFrom</a> <strong>method</strong></li>
</ul>
</div>
<div class="section" id="element-clustering">
<span id="ulcluster"></span><h3>Element Clustering<a class="headerlink" href="#element-clustering" title="Permalink to this headline">¶</a></h3>
<p>Naively one would expect that after all the <a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a> appearing in the <a class="reference internal" href="DatabaseDefinitions.html#ulconstraint"><span>constraint</span></a>
have been selected, it is trivial to compute the theory prediction: one must simply
sum up the weights (<span class="math">\(\sigma \times BR\)</span>) of all the selected <a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a>.
However, the selected <a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a> usually differ in their masses <a class="footnote-reference" href="#id8" id="id1">[*]</a> and the
experimental limit (see <a class="reference internal" href="DatabaseDefinitions.html#ulconstraint"><span>Upper Limit constraint</span></a>) assumes that all the <a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a> appearing
in the <a class="reference internal" href="DatabaseDefinitions.html#ulconstraint"><span>constraint</span></a> have the same mass (or mass array).
As a result, the selected <a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a> must be grouped into <em>clusters</em> of equal masses.
When grouping the <a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a>, however, one must allow for small mass differences,
since the experimental efficiencies should not be strongly sensitive to small mass
differences. For instance, assume two <a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a> contain identical mass arrays, except for the parent masses
which differ by 1 MeV. In this case it is obvious that for all experimental purposes the two <a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a>
have identical masses and should contribute to the same theory prediction (e.g. their weights should be
added when computing the signal cross section).
Unfortunately there is no way to
unambiguously define &#8216;&#8217;similar masses&#8217;&#8217; and the definition should depend on the <a class="reference internal" href="DatabaseDefinitions.html#expresult"><span>Experimental Result</span></a>, since
different results will be more or less sensitive to mass differences. SModelS uses an UL map-dependent
measure of the distance between two <a class="reference internal" href="TheoryDefinitions.html#element"><span>element</span></a> masses, as described in <a class="reference internal" href="#massdist"><span>Mass Distance</span></a>.</p>
<p>If two of the selected <a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a> have a <a class="reference internal" href="#massdist"><span>mass distance</span></a> smaller
than a maximum value (defined by <a class="reference external" href="../../../documentation/build/html/theory.html#theory.clusterTools.clusterElements">maxDist</a>),
they are gouped in the same mass cluster, as illustrated by the example below:</p>
<a class="reference internal image-reference" href="_images/ULcluster.png"><img alt="_images/ULcluster.png" src="_images/ULcluster.png" style="width: 80%;" /></a>
<p>Once all the <a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a> have been clustered, their weights can finally be added together
and compared against the experimental upper limit.</p>
<ul class="simple">
<li><strong>The clustering of elements is implemented by the</strong> <a class="reference external" href="../../../documentation/build/html/theory.html#theory.clusterTools.clusterElements">clusterElements</a>  <strong>method</strong>.</li>
</ul>
</div>
<div class="section" id="mass-distance">
<span id="massdist"></span><h3>Mass Distance<a class="headerlink" href="#mass-distance" title="Permalink to this headline">¶</a></h3>
<p>As mentioned <a class="reference internal" href="#ulcluster"><span>above</span></a>, in order to cluster the <a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a> it is necessary
to determine whether two <a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a> have similar masses (see <a class="reference internal" href="TheoryDefinitions.html#element"><span>element</span></a> and <a class="reference internal" href="TheoryDefinitions.html#bracketnotation"><span>Bracket Notation</span></a>
for more details on <a class="reference internal" href="TheoryDefinitions.html#element"><span>element</span></a> mass).
Since an absolute definition of &#8216;&#8217;similar masses&#8217;&#8217; is not possible and the sensitivity to mass differences
depends on the experimental result, SModelS uses an &#8216;&#8217;upper limit map-dependent&#8217;&#8217; definition. For each <a class="reference internal" href="TheoryDefinitions.html#element"><span>element</span></a>&#8216;s mass array,
the upper limit for the corresponding mass values is obtained from the UL map (see <a class="reference internal" href="DatabaseDefinitions.html#ultype"><span>UL-type result</span></a>).
This way, each mass array is mapped to a single number (the cross section upper limit for the experimental result).
Then the distance between the two <a class="reference internal" href="TheoryDefinitions.html#element"><span>element</span></a>&#8216;s masses is simply given by the relative difference between their respective
upper limits. More explicitly:</p>
<div class="math">
\[\begin{split}\mbox{Element } A\; (&amp; M_A = [[M1,M2,...],[m1,m2,...]]) \rightarrow \mbox{ Upper Limit}(M_A) = x\\
\mbox{Element } B\; (&amp; M_B = [[M1',M2',...],[m1',m2',...]]) \rightarrow \mbox{ Upper Limit}(M_B) = y\\
                                    &amp; \Rightarrow \mbox{mass distance}(A,B) = \frac{|x-y|}{(x+y)/2}\end{split}\]</div>
<p>where <span class="math">\(M_A,M_B\)</span> (<span class="math">\(x,y\)</span>) are the mass arrays (upper limits) for the <a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a> A and B, respectively.
If the mass distance of two <a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a> is smaller than <a class="reference external" href="../../../documentation/build/html/theory.html#theory.clusterTools.clusterElements">maxDist</a>,
the two masses are considered similar.</p>
<p>Notice that the above definition of mass distance quantifies the experimental analysis
sensitivity to mass differences, which is the relevant parameter when <a class="reference internal" href="#ulcluster"><span>clustering elements</span></a>.
Also, a check is performed to ensure that masses with very distinct values but similar upper limits are not
clustered together.</p>
<ul class="simple">
<li><strong>The mass distance function is implemented by the</strong> <a class="reference external" href="../../../documentation/build/html/theory.html#theory.auxiliaryFunctions.distance">distance</a> <strong>method</strong></li>
</ul>
</div>
</div>
<div class="section" id="theory-predictions-for-efficiency-map-results">
<h2>Theory Predictions for Efficiency Map Results<a class="headerlink" href="#theory-predictions-for-efficiency-map-results" title="Permalink to this headline">¶</a></h2>
<p>In order to compute the signal cross sections for a given <a class="reference internal" href="DatabaseDefinitions.html#emtype"><span>EM-type result</span></a>, so it can be compared
to the signal region limits, it is first necessary to apply the efficiencies (see <a class="reference internal" href="DatabaseDefinitions.html#emtype"><span>EM-type result</span></a>) to all the <a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a> generated
by the model <a class="reference internal" href="Decomposition.html"><em>decomposition</em></a>.
Notice that typically a single  <a class="reference internal" href="DatabaseDefinitions.html#emtype"><span>EM-type result</span></a> contains several signal regions (<a class="reference internal" href="DatabaseDefinitions.html#dataset"><span>DataSets</span></a>) and there will be a set of efficiencies
(or efficiency maps) for each <a class="reference internal" href="DatabaseDefinitions.html#dataset"><span>data set</span></a>. As a result, several theory predictions (one for each <a class="reference internal" href="DatabaseDefinitions.html#dataset"><span>data set</span></a>) will be computed.
This procedure is similar (in nature) to
the <a class="reference internal" href="#ulselection"><span>Element Selection</span></a> applied in the case of an <a class="reference internal" href="DatabaseDefinitions.html#ultype"><span>UL-type result</span></a>, except that now it must be repeated
for several <a class="reference internal" href="DatabaseDefinitions.html#dataset"><span>data sets</span></a> (signal regions).</p>
<p>After the <a class="reference internal" href="TheoryDefinitions.html#element"><span>element</span></a>&#8216;s weights have being rescaled by the corresponding efficiencies for the given <a class="reference internal" href="DatabaseDefinitions.html#dataset"><span>data set</span></a> (signal region),
all of them can be grouped together in a single cluster, which will provide a single theory prediction (signal
cross section) for each <a class="reference internal" href="DatabaseDefinitions.html#dataset"><span>DataSet</span></a>. Hence the <a class="reference internal" href="#emcluster"><span>element clustering</span></a> discussed below is completely trivial.
On the other hand the <a class="reference internal" href="#emselection"><span>element selection</span></a> is slightly more involved than in the <a class="reference internal" href="DatabaseDefinitions.html#ultype"><span>UL-type result</span></a>
case and will be discussed in more detail.</p>
<div class="section" id="emselection">
<span id="id3"></span><h3>Element Selection<a class="headerlink" href="#emselection" title="Permalink to this headline">¶</a></h3>
<p>The element selection for the case of a <a class="reference internal" href="DatabaseDefinitions.html#emtype"><span>EM-type result</span></a> consists of rescaling all the <a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a>
weights by their efficiencies, according to the efficiency map of the corresponding <a class="reference internal" href="DatabaseDefinitions.html#dataset"><span>DataSet</span></a>.
The efficiency for a given <a class="reference internal" href="DatabaseDefinitions.html#dataset"><span>DataSet</span></a> depends both on the <a class="reference internal" href="TheoryDefinitions.html#element"><span>element</span></a> mass and on its topology and particle content.
In practice the efficiencies for most of the <a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a> will be extremely small (or zero), hence only a subset effectively
contributes after the element selection  <a class="footnote-reference" href="#id9" id="id4">[†]</a>.
In the figure below we illustrate the element selection for the case of  a <a class="reference internal" href="DatabaseDefinitions.html#emtype"><span>EM-type result</span></a>/<a class="reference internal" href="DatabaseDefinitions.html#dataset"><span>DataSet</span></a>:</p>
<a class="reference internal image-reference" href="_images/EMselection.png" id="emselectionfig"><img alt="_images/EMselection.png" id="emselectionfig" src="_images/EMselection.png" style="width: 85%;" /></a>
<p>If, for instance, the analysis being considered vetoes <span class="math">\(jets\)</span> and <span class="math">\(\tau\)</span>&#8216;s in the final state,
we will have <span class="math">\(\epsilon_2,\, \epsilon_4 \simeq 0\)</span> for the example in the <a class="reference internal" href="#emselectionfig"><span>figure above</span></a>.
Nonetheless, the element selection for a  <a class="reference internal" href="DatabaseDefinitions.html#dataset"><span>DataSet</span></a> is usually more inclusive than
the one applied for the <a class="reference internal" href="DatabaseDefinitions.html#ultype"><span>UL-type result</span></a>, resulting in less conservative values for the theory prediction.</p>
<ul class="simple">
<li><strong>The element selection is implemented by the</strong> <a class="reference external" href="../../../documentation/build/html/theory.html#theoryPrediction._getElementsFrom">getElementsFrom</a> <strong>method</strong></li>
</ul>
</div>
<div class="section" id="emcluster">
<span id="id6"></span><h3>Element Clustering<a class="headerlink" href="#emcluster" title="Permalink to this headline">¶</a></h3>
<p>Unlike the clustering required in the case of <a class="reference internal" href="DatabaseDefinitions.html#ultype"><span>UL-type result</span></a>
(see <a class="reference internal" href="#ulcluster"><span>Element Clustering for an UL analysis</span></a>), after the efficiencies have been
applied to the element&#8217;s weights, there is no longer the necessity to group the <a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a>
according to their masses, since the mass differences have already been accounted for by the different efficiencies.
As a result, after the <a class="reference internal" href="#emselection"><span>element selection</span></a> all elements belong to a single cluster:</p>
<a class="reference internal image-reference" href="_images/EMcluster.png"><img alt="_images/EMcluster.png" src="_images/EMcluster.png" style="width: 80%;" /></a>
<ul class="simple">
<li><strong>The (trivial) clustering of elements is implemented by the</strong> <a class="reference external" href="../../../documentation/build/html/theory.html#theory.clusterTools.clusterElements">clusterElements</a>  <strong>method</strong>.</li>
</ul>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[*]</a></td><td>As discussed in <a class="reference internal" href="DatabaseDefinitions.html#databasedefs"><span>Database Definitions</span></a>,  <a class="reference internal" href="DatabaseDefinitions.html#ultype"><span>UL-type results</span></a> have a single <a class="reference internal" href="DatabaseDefinitions.html#dataset"><span>DataSet</span></a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[†]</a></td><td>When refering to an <a class="reference internal" href="TheoryDefinitions.html#element"><span>element</span></a> mass, we mean all the <a class="reference internal" href="TheoryDefinitions.html#odd-states"><span>intermediate state</span></a> masses
appearing in the <a class="reference internal" href="TheoryDefinitions.html#element"><span>element</span></a> (or the <a class="reference internal" href="TheoryDefinitions.html#element"><span>element</span></a> mass array). Two <a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a> are considered to have identical
masses if their mass arrays are identical (see <a class="reference internal" href="TheoryDefinitions.html#element"><span>element</span></a> and <a class="reference internal" href="TheoryDefinitions.html#bracketnotation"><span>Bracket Notation</span></a>
for more details).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[‡]</td><td>The number of <a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a> passing the selection also depends on the availability of efficiency maps
for the <a class="reference internal" href="TheoryDefinitions.html#element"><span>elements</span></a> generated by the decomposition. Whenever there are no efficiencies available for a
element, the efficiency is taken to be zero.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="DatabaseStructure.html" class="btn btn-neutral float-right" title="Database of Experimental Results" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Decomposition.html" class="btn btn-neutral" title="Decomposition into Simplified Models" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Federico Ambrogi, Sabine Kraml, Suchita Kulkarni, Ursula Laa, Andre Lessa, Veronika Magerl, Wolfgang Magerl, Doris Proschofsky, Michael Traub, Jory Sonneveld, Wolfgang Waltenberger.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.1.0patch1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>