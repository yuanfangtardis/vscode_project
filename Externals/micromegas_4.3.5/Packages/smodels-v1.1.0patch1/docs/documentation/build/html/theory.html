

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>theory package &mdash; SModelS 1.1.0patch1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="SModelS 1.1.0patch1 documentation" href="index.html"/>
        <link rel="next" title="experiment package" href="experiment.html"/>
        <link rel="prev" title="SModelS Code Documentation" href="index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> SModelS
          

          
          </a>

          
            
            
              <div class="version">
                1.1.0patch1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="">theory package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-theory.auxiliaryFunctions">theory.auxiliaryFunctions module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-theory.branch">theory.branch module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-theory.clusterTools">theory.clusterTools module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-theory.crossSection">theory.crossSection module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-theory.element">theory.element module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-theory.exceptions">theory.exceptions module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-theory.lheDecomposer">theory.lheDecomposer module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-theory.lheReader">theory.lheReader module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-theory.particleNames">theory.particleNames module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-theory.slhaDecomposer">theory.slhaDecomposer module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-theory.theoryPrediction">theory.theoryPrediction module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-theory.topology">theory.topology module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-theory">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="experiment.html">experiment package</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools.html">tools package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">SModelS</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>theory package</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/theory.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="theory-package">
<h1>theory package<a class="headerlink" href="#theory-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-theory.auxiliaryFunctions">
<span id="theory-auxiliaryfunctions-module"></span><h2>theory.auxiliaryFunctions module<a class="headerlink" href="#module-theory.auxiliaryFunctions" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-auxiliaryFunctions"></span><dl class="function">
<dt id="theory.auxiliaryFunctions.cGtr">
<code class="descname">cGtr</code><span class="sig-paren">(</span><em>weightA</em>, <em>weightB</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/auxiliaryFunctions.html#cGtr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.auxiliaryFunctions.cGtr" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the auxiliary greater function.</p>
<p>Return a number between 0 and 1 depending on how much it is violated
(0 = A &gt; B, 1 = A &lt;&lt; B).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">XSectioList object with the values for each label.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="theory.auxiliaryFunctions.cSim">
<code class="descname">cSim</code><span class="sig-paren">(</span><em>*weights</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/auxiliaryFunctions.html#cSim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.auxiliaryFunctions.cSim" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the auxiliar similar function.</p>
<p>Return the maximum relative difference between any element weights of the
list, normalized to [0,1].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">XSectionList object with the values for each label.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="theory.auxiliaryFunctions.distance">
<code class="descname">distance</code><span class="sig-paren">(</span><em>xmass1</em>, <em>xmass2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/auxiliaryFunctions.html#distance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.auxiliaryFunctions.distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Define distance between two mass positions in upper limit space.
The distance is defined as d = 2*|xmass1-xmass2|/(xmass1+xmass2).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>xmass1</strong> &#8211; upper limit value (in fb) for the mass1</li>
<li><strong>xmass2</strong> &#8211; upper limit value (in fb) for the mass2</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">relative mass distance in upper limit space</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="theory.auxiliaryFunctions.index_bisect">
<code class="descname">index_bisect</code><span class="sig-paren">(</span><em>inlist</em>, <em>el</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/auxiliaryFunctions.html#index_bisect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.auxiliaryFunctions.index_bisect" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index where to insert item el in inlist.
inlist is assumed to be sorted and a comparison function (lt or cmp)
must exist for el and the other elements of the list.
If el already appears in the list, inlist.insert(el) will
insert just before the leftmost el already there.</p>
</dd></dl>

<dl class="function">
<dt id="theory.auxiliaryFunctions.massAvg">
<code class="descname">massAvg</code><span class="sig-paren">(</span><em>massList</em>, <em>method='weighted'</em>, <em>weights=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/auxiliaryFunctions.html#massAvg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.auxiliaryFunctions.massAvg" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the average mass of massList according to method.</p>
<p>If method=weighted but weights were not properly defined,
switch method to harmonic.    
If massList contains a zero mass, switch method to mean.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>method</strong> &#8211; possible values: harmonic, mean, weighted</li>
<li><strong>weights</strong> &#8211; weights of elements (only for weighted average)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="theory.auxiliaryFunctions.massPosition">
<code class="descname">massPosition</code><span class="sig-paren">(</span><em>mass</em>, <em>txdata</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/auxiliaryFunctions.html#massPosition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.auxiliaryFunctions.massPosition" title="Permalink to this definition">¶</a></dt>
<dd><p>Give mass position in upper limit space.    
Use the analysis experimental limit data. 
:param txdata: TxNameData object holding the data and interpolation</p>
</dd></dl>

</div>
<div class="section" id="module-theory.branch">
<span id="theory-branch-module"></span><h2>theory.branch module<a class="headerlink" href="#module-theory.branch" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-branch"></span><dl class="class">
<dt id="theory.branch.Branch">
<em class="property">class </em><code class="descname">Branch</code><span class="sig-paren">(</span><em>info=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/branch.html#Branch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.branch.Branch" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>An instance of this class represents a branch.    
A branch-element can be constructed from a string (e.g., (&#8216;[b,b],[W]&#8217;).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>masses</strong> &#8211; list of masses for the intermediate states</li>
<li><strong>particles</strong> &#8211; list of particles (strings) for the final states</li>
<li><strong>PIDs</strong> &#8211; a list of the pdg numbers of the intermediate states appearing in the branch.
If the branch represents more than one possible pdg list, PIDs will correspond
to a nested list (PIDs = [[pid1,pid2,...],[pidA,pidB,...])</li>
<li><strong>maxWeight</strong> &#8211; weight of the branch (XSection object)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="theory.branch.Branch.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/branch.html#Branch.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.branch.Branch.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an independent copy of self.        
Faster than deepcopy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Branch object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.branch.Branch.decayDaughter">
<code class="descname">decayDaughter</code><span class="sig-paren">(</span><em>brDictionary</em>, <em>massDictionary</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/branch.html#Branch.decayDaughter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.branch.Branch.decayDaughter" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a list of all new branches generated by the 1-step cascade
decay of the current branch daughter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>brDictionary</strong> &#8211; dictionary with the decay information
for all intermediate states (values are br objects, see pyslha)</li>
<li><strong>massDictionary</strong> &#8211; dictionary containing the masses for all intermediate states.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of extended branches (Branch objects). Empty list if daughter is stable or
if daughterID was not defined.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.branch.Branch.getLength">
<code class="descname">getLength</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/branch.html#Branch.getLength"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.branch.Branch.getLength" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the branch length (number of R-odd particles).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">length of branch (number of R-odd particles)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.branch.Branch.particlesMatch">
<code class="descname">particlesMatch</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/branch.html#Branch.particlesMatch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.branch.Branch.particlesMatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two Branches for matching particles, 
allow for inclusive particle labels (such as the ones defined in particles.py)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> &#8211; branch to be compared (Branch object)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if branches are equal (particles and masses match); False otherwise.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.branch.Branch.setInfo">
<code class="descname">setInfo</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/branch.html#Branch.setInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.branch.Branch.setInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the number of vertices (vertnumb) and number of
particles in each vertex (vertpats) properties, if they have not
been defined yet.</p>
</dd></dl>

<dl class="method">
<dt id="theory.branch.Branch.sortParticles">
<code class="descname">sortParticles</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/branch.html#Branch.sortParticles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.branch.Branch.sortParticles" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort the particles inside each vertex</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="theory.branch.decayBranches">
<code class="descname">decayBranches</code><span class="sig-paren">(</span><em>branchList, brDictionary, massDictionary, sigcut=0.00E+00 [fb]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/branch.html#decayBranches"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.branch.decayBranches" title="Permalink to this definition">¶</a></dt>
<dd><p>Decay all branches from branchList until all unstable intermediate states have decayed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>branchList</strong> &#8211; list of Branch() objects containing the initial mothers</li>
<li><strong>brDictionary</strong> &#8211; dictionary with the decay information
for all intermediate states (values are br objects, see pyslha)</li>
<li><strong>massDictionary</strong> &#8211; dictionary containing the masses for all intermediate states.</li>
<li><strong>sigcut</strong> &#8211; minimum sigma*BR to be generated, by default sigcut = 0.
(all branches are kept)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of branches (Branch objects)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-theory.clusterTools">
<span id="theory-clustertools-module"></span><h2>theory.clusterTools module<a class="headerlink" href="#module-theory.clusterTools" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-clusterTools"></span><dl class="class">
<dt id="theory.clusterTools.ElementCluster">
<em class="property">class </em><code class="descname">ElementCluster</code><a class="reference internal" href="_modules/theory/clusterTools.html#ElementCluster"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.clusterTools.ElementCluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>An instance of this class represents a cluster.    
This class is used to store the relevant information about a cluster of
elements and to manipulate this information.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><strong>elements</strong> &#8211; list of elements in the cluster (Element objects)</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="theory.clusterTools.ElementCluster.getAvgMass">
<code class="descname">getAvgMass</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/clusterTools.html#ElementCluster.getAvgMass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.clusterTools.ElementCluster.getAvgMass" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the average mass of all elements belonging to the cluster.
If the cluster does not refer to a TxName (i.e. in efficiency map results)
AND the cluster contains more than one element (assuming they differ in
the masses), returns None.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">average mass array</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.clusterTools.ElementCluster.getDataType">
<code class="descname">getDataType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/clusterTools.html#ElementCluster.getDataType"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.clusterTools.ElementCluster.getDataType" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks to which type of data (efficiency map or upper limit)
the cluster refers to. It uses the cluster.txnames attribute.
If not defined, returns None 
:return: upperLimits or efficiencyMap (string)</p>
</dd></dl>

<dl class="method">
<dt id="theory.clusterTools.ElementCluster.getIDs">
<code class="descname">getIDs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/clusterTools.html#ElementCluster.getIDs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.clusterTools.ElementCluster.getIDs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return list of all element IDs appearing in the cluster
:return: list of element IDs</p>
</dd></dl>

<dl class="method">
<dt id="theory.clusterTools.ElementCluster.getPIDs">
<code class="descname">getPIDs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/clusterTools.html#ElementCluster.getPIDs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.clusterTools.ElementCluster.getPIDs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of all PIDs appearing in all elements in the cluster,
i.e. [ [[pdg1, pdg2,...],[pdg3,pdg4,...]], [[pdg1&#8217;, pdg2&#8217;,...],[pdg3&#8217;,pdg4&#8217;,...]]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of PIDs</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.clusterTools.ElementCluster.getTotalXSec">
<code class="descname">getTotalXSec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/clusterTools.html#ElementCluster.getTotalXSec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.clusterTools.ElementCluster.getTotalXSec" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum over the cross sections of all elements belonging to
the cluster.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">sum of weights of all the elements in the cluster (XSectionList object)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="theory.clusterTools.IndexCluster">
<em class="property">class </em><code class="descname">IndexCluster</code><span class="sig-paren">(</span><em>massMap=None</em>, <em>posMap=None</em>, <em>wMap=None</em>, <em>indices=set([])</em>, <em>txdata=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/clusterTools.html#IndexCluster"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.clusterTools.IndexCluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>An instance of this class represents a cluster storing element indices.    
This auxiliary class is used to store element indices and positions in
upper limit space. It is only used by the clustering algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>indices</strong> &#8211; list of integers mapping the cluster elements to their position in the list
(1st element -&gt; index 0, 2nd element -&gt; index 1,...)</li>
<li><strong>avgPosition</strong> &#8211; position in upper limit space for the cluster average mass</li>
<li><strong>massMap</strong> &#8211; dictionary with indices as keys and the corresponding element mass as values</li>
<li><strong>positionMap</strong> &#8211; dictionary with indices as keys and the corresponding element position
in upper limit space as values</li>
<li><strong>weightMap</strong> &#8211; dictionary with indices as keys and the corresponding element weight
as values</li>
<li><strong>txdata</strong> &#8211; TxNameData object to be used for computing distances in UL space</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="theory.clusterTools.IndexCluster.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>iels</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/clusterTools.html#IndexCluster.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.clusterTools.IndexCluster.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an index or a list of indices to the list of indices and update
the avgPosition value.</p>
</dd></dl>

<dl class="method">
<dt id="theory.clusterTools.IndexCluster.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/clusterTools.html#IndexCluster.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.clusterTools.IndexCluster.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of the index cluster (faster than deepcopy).</p>
</dd></dl>

<dl class="method">
<dt id="theory.clusterTools.IndexCluster.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><em>iels</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/clusterTools.html#IndexCluster.remove"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.clusterTools.IndexCluster.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove an index or a list of indices to the list of indices and
update the avgPosition value.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="theory.clusterTools.clusterElements">
<code class="descname">clusterElements</code><span class="sig-paren">(</span><em>elements</em>, <em>maxDist</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/clusterTools.html#clusterElements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.clusterTools.clusterElements" title="Permalink to this definition">¶</a></dt>
<dd><p>Cluster the original elements according to their mass distance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>elements</strong> &#8211; list of elements (Element objects)</li>
<li><strong>txname</strong> &#8211; TxName object to be used for computing distances in UL space</li>
<li><strong>maxDist</strong> &#8211; maximum mass distance for clustering two elements</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of clusters (ElementCluster objects)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="theory.clusterTools.groupAll">
<code class="descname">groupAll</code><span class="sig-paren">(</span><em>elements</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/clusterTools.html#groupAll"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.clusterTools.groupAll" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a single cluster containing all the elements.
Skip mother elements which contain the daughter in the list (avoids double counting).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>elements</strong> &#8211; List of Element objects</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">ElementCluster object containing all unique elements</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-theory.crossSection">
<span id="theory-crosssection-module"></span><h2>theory.crossSection module<a class="headerlink" href="#module-theory.crossSection" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-crossSection"></span><dl class="class">
<dt id="theory.crossSection.XSection">
<em class="property">class </em><code class="descname">XSection</code><a class="reference internal" href="_modules/theory/crossSection.html#XSection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>An instance of this class represents a cross section.</p>
<p>This class is used to store the information of a single cross section
(value, paritcle ids, center of mass, order and label).</p>
<p>order = 0 (LO), 1 (NLO) or 2 (NLL).</p>
<dl class="method">
<dt id="theory.crossSection.XSection.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/crossSection.html#XSection.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSection.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates an independent copy of self.</p>
<p>Faster than deepcopy.</p>
</dd></dl>

<dl class="method">
<dt id="theory.crossSection.XSection.niceStr">
<code class="descname">niceStr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/crossSection.html#XSection.niceStr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSection.niceStr" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a more human readable string. The string format is:
Sqrts: self.info.sqrts,  Weight: self.value</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="theory.crossSection.XSectionInfo">
<em class="property">class </em><code class="descname">XSectionInfo</code><span class="sig-paren">(</span><em>sqrts=None</em>, <em>order=None</em>, <em>label=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/crossSection.html#XSectionInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>An instance of this class represents information regarding a cross section.</p>
<p>This class is used to store information of a cross section (center of
mass, order and label).</p>
<dl class="method">
<dt id="theory.crossSection.XSectionInfo.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/crossSection.html#XSectionInfo.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionInfo.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an independent copy of self.</p>
<p>Faster than deepcopy.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="theory.crossSection.XSectionList">
<em class="property">class </em><code class="descname">XSectionList</code><span class="sig-paren">(</span><em>infoList=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/crossSection.html#XSectionList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionList" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>An instance of this class represents a list of cross sections.</p>
<p>This class is used to store a list of cross sections.</p>
<dl class="method">
<dt id="theory.crossSection.XSectionList.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>newxsec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/crossSection.html#XSectionList.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionList.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Append a XSection object to the list.</p>
</dd></dl>

<dl class="method">
<dt id="theory.crossSection.XSectionList.combineWith">
<code class="descname">combineWith</code><span class="sig-paren">(</span><em>newXsecs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/crossSection.html#XSectionList.combineWith"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionList.combineWith" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new list of cross sections.</p>
<p>If the new cross sections already appear (have same order and sqrts),
add its value to the original value, otherwise append it to the list.
The particle IDs are ignored when adding cross sections. Hence, they
are set to (None, None) if any cross sections are combined.</p>
</dd></dl>

<dl class="method">
<dt id="theory.crossSection.XSectionList.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/crossSection.html#XSectionList.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionList.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates an independent copy of itself. Faster than deepcopy.</p>
</dd></dl>

<dl class="method">
<dt id="theory.crossSection.XSectionList.delete">
<code class="descname">delete</code><span class="sig-paren">(</span><em>xSec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/crossSection.html#XSectionList.delete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionList.delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the cross section entry from the list.</p>
</dd></dl>

<dl class="method">
<dt id="theory.crossSection.XSectionList.getDictionary">
<code class="descname">getDictionary</code><span class="sig-paren">(</span><em>groupBy='pids'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/crossSection.html#XSectionList.getDictionary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionList.getDictionary" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the list of XSection objects to a nested dictionary.</p>
<p>First level keys are the particles IDs (if groupBy == pids) or labels
(if groupBy == labels) and values are the cross section labels or
particle IDs and the cross section value.</p>
</dd></dl>

<dl class="method">
<dt id="theory.crossSection.XSectionList.getInfo">
<code class="descname">getInfo</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/crossSection.html#XSectionList.getInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionList.getInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Get basic info about the cross sections appearing in the list (order,
value and label).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of XSectionInfo objects</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.crossSection.XSectionList.getMaxXsec">
<code class="descname">getMaxXsec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/crossSection.html#XSectionList.getMaxXsec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionList.getMaxXsec" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the maximum cross section value appearing in the list.</p>
</dd></dl>

<dl class="method">
<dt id="theory.crossSection.XSectionList.getMinXsec">
<code class="descname">getMinXsec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/crossSection.html#XSectionList.getMinXsec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionList.getMinXsec" title="Permalink to this definition">¶</a></dt>
<dd><p>Get minimum cross section value appearing in the list.</p>
</dd></dl>

<dl class="method">
<dt id="theory.crossSection.XSectionList.getPIDpairs">
<code class="descname">getPIDpairs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/crossSection.html#XSectionList.getPIDpairs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionList.getPIDpairs" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all particle ID pairs appearing in the list.</p>
</dd></dl>

<dl class="method">
<dt id="theory.crossSection.XSectionList.getPIDs">
<code class="descname">getPIDs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/crossSection.html#XSectionList.getPIDs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionList.getPIDs" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all particle IDs appearing in the list.</p>
</dd></dl>

<dl class="method">
<dt id="theory.crossSection.XSectionList.getXsecsFor">
<code class="descname">getXsecsFor</code><span class="sig-paren">(</span><em>item</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/crossSection.html#XSectionList.getXsecsFor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionList.getXsecsFor" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of XSection objects for item (label, pid, sqrts).</p>
</dd></dl>

<dl class="method">
<dt id="theory.crossSection.XSectionList.niceStr">
<code class="descname">niceStr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/crossSection.html#XSectionList.niceStr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionList.niceStr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="theory.crossSection.XSectionList.order">
<code class="descname">order</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/crossSection.html#XSectionList.order"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionList.order" title="Permalink to this definition">¶</a></dt>
<dd><p>Order the cross section in the list by their PDG pairs</p>
</dd></dl>

<dl class="method">
<dt id="theory.crossSection.XSectionList.removeLowerOrder">
<code class="descname">removeLowerOrder</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/crossSection.html#XSectionList.removeLowerOrder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.XSectionList.removeLowerOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Keep only the highest order cross section for each process in the list.</p>
<p>Remove order information and set default labels.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="theory.crossSection.getXsecFromLHEFile">
<code class="descname">getXsecFromLHEFile</code><span class="sig-paren">(</span><em>lhefile</em>, <em>addEvents=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/crossSection.html#getXsecFromLHEFile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.getXsecFromLHEFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain cross sections from input LHE file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhefile</strong> &#8211; LHE input file with unweighted MC events</li>
<li><strong>addEvents</strong> &#8211; if True, add cross sections with the same mothers,
otherwise return the event weight for each pair of mothers</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a XSectionList object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="theory.crossSection.getXsecFromSLHAFile">
<code class="descname">getXsecFromSLHAFile</code><span class="sig-paren">(</span><em>slhafile, useXSecs=None, xsecUnit=1.00E+00 [pb]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/crossSection.html#getXsecFromSLHAFile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.crossSection.getXsecFromSLHAFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain cross sections for pair production of R-odd particles from input SLHA file.
The default unit for cross section is pb.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>slhafile</strong> &#8211; SLHA input file with cross sections</li>
<li><strong>useXSecs</strong> &#8211; if defined enables the user to select cross sections to
use. Must be a XSecInfoList object</li>
<li><strong>xsecUnit</strong> &#8211; cross section unit in the input file (must be a Unum unit)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a XSectionList object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-theory.element">
<span id="theory-element-module"></span><h2>theory.element module<a class="headerlink" href="#module-theory.element" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-element"></span><dl class="class">
<dt id="theory.element.Element">
<em class="property">class </em><code class="descname">Element</code><span class="sig-paren">(</span><em>info=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/element.html#Element"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>An instance of this class represents an element.    
This class possesses a pair of branches and the element weight
(cross-section * BR).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>branches</strong> &#8211; list of branches (Branch objects)</li>
<li><strong>weight</strong> &#8211; element weight (cross-section * BR)</li>
<li><strong>motherElements</strong> &#8211; only for elements generated from a parent element
by mass compression, invisible compression,etc.
Holds a pair of (whence, mother element), where
whence describes what process generated the element</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="theory.element.Element.checkConsistency">
<code class="descname">checkConsistency</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/element.html#Element.checkConsistency"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.checkConsistency" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the particles defined in the element exist and are consistent
with the element info.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True if the element is consistent. Print error message
and exits otherwise.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.combineMotherElements">
<code class="descname">combineMotherElements</code><span class="sig-paren">(</span><em>el2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/element.html#Element.combineMotherElements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.combineMotherElements" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine mother elements from self and el2 into self</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>el2</strong> &#8211; element (Element Object)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.combinePIDs">
<code class="descname">combinePIDs</code><span class="sig-paren">(</span><em>el2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/element.html#Element.combinePIDs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.combinePIDs" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine the PIDs of both elements. If the PIDs already appear in self,
do not add them to the list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>el2</strong> &#8211; element (Element Object)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.compressElement">
<code class="descname">compressElement</code><span class="sig-paren">(</span><em>doCompress</em>, <em>doInvisible</em>, <em>minmassgap</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/element.html#Element.compressElement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.compressElement" title="Permalink to this definition">¶</a></dt>
<dd><p>Keep compressing the original element and the derived ones till they
can be compressed no more.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>doCompress</strong> &#8211; if True, perform mass compression</li>
<li><strong>doInvisible</strong> &#8211; if True, perform invisible compression</li>
<li><strong>minmassgap</strong> &#8211; value (in GeV) of the maximum 
mass difference for compression
(if mass difference &lt; minmassgap, perform mass compression)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list with the compressed elements (Element objects)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/element.html#Element.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a copy of self.        
Faster than deepcopy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">copy of element (Element object)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.getDaughters">
<code class="descname">getDaughters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/element.html#Element.getDaughters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.getDaughters" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a pair of daughter IDs (PDGs of the last intermediate 
state appearing the cascade decay), i.e. [ [pdgLSP1,pdgLSP2] ]    
Can be a list, if the element combines several daughters:
[ [pdgLSP1,pdgLSP2],  [pdgLSP1&#8217;,pdgLSP2&#8217;]]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of PDG ids</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.getEinfo">
<code class="descname">getEinfo</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/element.html#Element.getEinfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.getEinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Get topology info from particle string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dictionary containing vertices and number of final states information</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.getMasses">
<code class="descname">getMasses</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/element.html#Element.getMasses"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.getMasses" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the array of masses in the element.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of masses (mass array)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.getMothers">
<code class="descname">getMothers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/element.html#Element.getMothers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.getMothers" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a pair of mother IDs (PDGs of the first intermediate 
state appearing the cascade decay), i.e. [ [pdgMOM1,pdgMOM2] ]    
Can be a list, if the element combines several mothers:
[ [pdgMOM1,pdgMOM2],  [pdgMOM1&#8217;,pdgMOM2&#8217;]]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of PDG ids</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.getPIDs">
<code class="descname">getPIDs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/element.html#Element.getPIDs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.getPIDs" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the list of IDs (PDGs of the intermediate states appearing the cascade decay), i.e.
[  [[pdg1,pdg2,...],[pdg3,pdg4,...]] ].
The list might have more than one entry if the element combines different pdg lists:
[  [[pdg1,pdg2,...],[pdg3,pdg4,...]],  [[pdg1&#8217;,pdg2&#8217;,...],[pdg3&#8217;,pdg4&#8217;,...]], ...]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of PDG ids</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.getParticles">
<code class="descname">getParticles</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/element.html#Element.getParticles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.getParticles" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the array of particles in the element.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of particle strings</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.hasTopInList">
<code class="descname">hasTopInList</code><span class="sig-paren">(</span><em>elementList</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/element.html#Element.hasTopInList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.hasTopInList" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the element topology matches any of the topologies in the
element list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>elementList</strong> &#8211; list of elements (Element objects)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True, if element topology has a match in the list, False otherwise.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.invisibleCompress">
<code class="descname">invisibleCompress</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/element.html#Element.invisibleCompress"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.invisibleCompress" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform invisible compression.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">compressed copy of the element, if element ends with invisible
particles; None, if compression is not possible</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.massCompress">
<code class="descname">massCompress</code><span class="sig-paren">(</span><em>minmassgap</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/element.html#Element.massCompress"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.massCompress" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform mass compression.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>minmassgap</strong> &#8211; value (in GeV) of the maximum 
mass difference for compression
(if mass difference &lt; minmassgap -&gt; perform mass compression)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">compressed copy of the element, if two masses in this
element are degenerate; None, if compression is not possible;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.particlesMatch">
<code class="descname">particlesMatch</code><span class="sig-paren">(</span><em>other</em>, <em>branchOrder=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/element.html#Element.particlesMatch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.particlesMatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two Elements for matching particles only.
Allow for inclusive particle labels (such as the ones defined in particles.py).
If branchOrder = False, check both branch orderings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>other</strong> &#8211; element to be compared (Element object)</li>
<li><strong>branchOrder</strong> &#8211; If False, check both orderings, otherwise
check the same branch ordering</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True, if particles match; False, else;</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.setMasses">
<code class="descname">setMasses</code><span class="sig-paren">(</span><em>mass</em>, <em>sameOrder=True</em>, <em>opposOrder=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/element.html#Element.setMasses"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.setMasses" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the element masses to the input mass array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mass</strong> &#8211; list of masses ([[masses for branch1],[masses for branch2]])</li>
<li><strong>sameOrder</strong> &#8211; if True, set the masses to the same branch ordering
If True and opposOrder=True, set the masses to the
smaller of the two orderings.</li>
<li><strong>opposOrder</strong> &#8211; if True, set the masses to the opposite branch ordering.
If True and sameOrder=True, set the masses to the
smaller of the two orderings.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.sortBranches">
<code class="descname">sortBranches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/element.html#Element.sortBranches"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.sortBranches" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort branches. The smallest branch is the first one.
See the Branch object for definition of branch size and comparison</p>
</dd></dl>

<dl class="method">
<dt id="theory.element.Element.switchBranches">
<code class="descname">switchBranches</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/element.html#Element.switchBranches"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.element.Element.switchBranches" title="Permalink to this definition">¶</a></dt>
<dd><p>Switch branches, if the element contains a pair of them.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">element with switched branches (Element object)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-theory.exceptions">
<span id="theory-exceptions-module"></span><h2>theory.exceptions module<a class="headerlink" href="#module-theory.exceptions" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-experiment.exceptions"></span><dl class="exception">
<dt id="theory.exceptions.SModelSTheoryError">
<em class="property">exception </em><code class="descname">SModelSTheoryError</code><span class="sig-paren">(</span><em>value=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/exceptions.html#SModelSTheoryError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.exceptions.SModelSTheoryError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></code></p>
<p>Class to define SModelS specific errors</p>
</dd></dl>

</div>
<div class="section" id="module-theory.lheDecomposer">
<span id="theory-lhedecomposer-module"></span><h2>theory.lheDecomposer module<a class="headerlink" href="#module-theory.lheDecomposer" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-lheDecomposer"></span><dl class="function">
<dt id="theory.lheDecomposer.decompose">
<code class="descname">decompose</code><span class="sig-paren">(</span><em>lhefile, inputXsecs=None, nevts=None, doCompress=False, doInvisible=False, minmassgap=-1.00E+00 [GeV]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/lheDecomposer.html#decompose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.lheDecomposer.decompose" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform LHE-based decomposition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lhefile</strong> &#8211; LHE file with e.g. pythia events</li>
<li><strong>inputXsecs</strong> &#8211; xSectionList object with cross sections for the mothers
appearing in the LHE file. If None, use information from file.</li>
<li><strong>nevts</strong> &#8211; (maximum) number of events used in the decomposition. If
None, all events from file are processed.</li>
<li><strong>doCompress</strong> &#8211; mass compression option (True/False)</li>
<li><strong>doInvisible</strong> &#8211; invisible compression option (True/False)</li>
<li><strong>minmassgap</strong> &#8211; minimum mass gap for mass compression (only used if
doCompress=True)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of topologies (TopologyList object)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="theory.lheDecomposer.elementFromEvent">
<code class="descname">elementFromEvent</code><span class="sig-paren">(</span><em>event</em>, <em>weight=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/lheDecomposer.html#elementFromEvent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.lheDecomposer.elementFromEvent" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an element from a LHE event and the corresponding event weight.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>event</strong> &#8211; LHE event</li>
<li><strong>weight</strong> &#8211; event weight. Must be a XSectionList object (usually with a
single entry) or None if not specified.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">element</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-theory.lheReader">
<span id="theory-lhereader-module"></span><h2>theory.lheReader module<a class="headerlink" href="#module-theory.lheReader" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-lheReader"></span><dl class="class">
<dt id="theory.lheReader.LheReader">
<em class="property">class </em><code class="descname">LheReader</code><span class="sig-paren">(</span><em>filename</em>, <em>nmax=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/lheReader.html#LheReader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.lheReader.LheReader" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>An instance of this class represents a reader for LHE files.</p>
<dl class="method">
<dt id="theory.lheReader.LheReader.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/lheReader.html#LheReader.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.lheReader.LheReader.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close the lhe file, if open.</p>
</dd></dl>

<dl class="method">
<dt id="theory.lheReader.LheReader.event">
<code class="descname">event</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/lheReader.html#LheReader.event"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.lheReader.LheReader.event" title="Permalink to this definition">¶</a></dt>
<dd><p>Get next event.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">SmsEvent; None if no event is left to be read.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.lheReader.LheReader.next">
<code class="descname">next</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/lheReader.html#LheReader.next"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.lheReader.LheReader.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Get next element in iteration.</p>
<p>Needed for the iterator.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="theory.lheReader.Particle">
<em class="property">class </em><code class="descname">Particle</code><a class="reference internal" href="_modules/theory/lheReader.html#Particle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.lheReader.Particle" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>An instance of this class represents a particle.</p>
</dd></dl>

<dl class="class">
<dt id="theory.lheReader.SmsEvent">
<em class="property">class </em><code class="descname">SmsEvent</code><span class="sig-paren">(</span><em>eventnr=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/lheReader.html#SmsEvent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.lheReader.SmsEvent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Event class featuring a list of particles and some convenience functions.</p>
<dl class="method">
<dt id="theory.lheReader.SmsEvent.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>particle</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/lheReader.html#SmsEvent.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.lheReader.SmsEvent.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add particle to the event.</p>
</dd></dl>

<dl class="method">
<dt id="theory.lheReader.SmsEvent.getMom">
<code class="descname">getMom</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/lheReader.html#SmsEvent.getMom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.lheReader.SmsEvent.getMom" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the pdgs of the mothers, None if a problem occurs.</p>
</dd></dl>

<dl class="method">
<dt id="theory.lheReader.SmsEvent.metaInfo">
<code class="descname">metaInfo</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/lheReader.html#SmsEvent.metaInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.lheReader.SmsEvent.metaInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the meta information of &#8216;key&#8217;, None if info does not exist.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-theory.particleNames">
<span id="theory-particlenames-module"></span><h2>theory.particleNames module<a class="headerlink" href="#module-theory.particleNames" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-particleNames"></span><dl class="function">
<dt id="theory.particleNames.elementsInStr">
<code class="descname">elementsInStr</code><span class="sig-paren">(</span><em>instring</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/particleNames.html#elementsInStr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.particleNames.elementsInStr" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse instring and return a list of elements appearing in instring.
instring can also be a list of strings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of elements appearing in instring in string format</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="theory.particleNames.getName">
<code class="descname">getName</code><span class="sig-paren">(</span><em>pdg</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/particleNames.html#getName"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.particleNames.getName" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert pdg number to particle name according to the dictionaries rOdd and
rEven.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">particle name (e.g. gluino, mu-, ...)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="theory.particleNames.getPdg">
<code class="descname">getPdg</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/particleNames.html#getPdg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.particleNames.getPdg" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a name to the pdg number according to the dictionaries rOdd and
rEven.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">particle pdg; None, if name could not be resolved</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="theory.particleNames.simParticles">
<code class="descname">simParticles</code><span class="sig-paren">(</span><em>plist1</em>, <em>plist2</em>, <em>useDict=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/particleNames.html#simParticles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.particleNames.simParticles" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares two lists of particle names. Allows for dictionary
labels (Ex: L = l, l+ = l, l = l-,...). Ignores particle ordering inside
the list</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>plist1</strong> &#8211; first list of particle names, e.g. [&#8216;l&#8217;,&#8217;jet&#8217;]</li>
<li><strong>plist2</strong> &#8211; second list of particle names</li>
<li><strong>useDict</strong> &#8211; use the translation dictionary, i.e. allow e to stand for
e+ or e-, l+ to stand for e+ or mu+, etc</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">True/False if the particles list match (ignoring order)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="theory.particleNames.vertInStr">
<code class="descname">vertInStr</code><span class="sig-paren">(</span><em>instring</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/particleNames.html#vertInStr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.particleNames.vertInStr" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses instring (or a list of strings) and returns the list of particle
vertices appearing in instring.</p>
</dd></dl>

</div>
<div class="section" id="module-theory.slhaDecomposer">
<span id="theory-slhadecomposer-module"></span><h2>theory.slhaDecomposer module<a class="headerlink" href="#module-theory.slhaDecomposer" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-slhaDecomposer"></span><dl class="function">
<dt id="theory.slhaDecomposer.decompose">
<code class="descname">decompose</code><span class="sig-paren">(</span><em>slhafile, sigcut=1.00E-01 [fb], doCompress=False, doInvisible=False, minmassgap=-1.00E+00 [GeV], useXSecs=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/slhaDecomposer.html#decompose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.slhaDecomposer.decompose" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform SLHA-based decomposition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sigcut</strong> &#8211; minimum sigma*BR to be generated, by default sigcut = 0.1 fb</li>
<li><strong>doCompress</strong> &#8211; turn mass compression on/off</li>
<li><strong>doInvisible</strong> &#8211; turn invisible compression on/off</li>
<li><strong>minmassgap</strong> &#8211; maximum value (in GeV) for considering two R-odd particles
degenerate (only revelant for doCompress=True )</li>
<li><strong>useXSecs</strong> &#8211; optionally a dictionary with cross sections for pair
production, by default reading the cross sections
from the SLHA file.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of topologies (TopologyList object)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-theory.theoryPrediction">
<span id="theory-theoryprediction-module"></span><h2>theory.theoryPrediction module<a class="headerlink" href="#module-theory.theoryPrediction" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-theoryPrediction"></span><dl class="function">
<dt id="theoryPrediction._getElementsFrom">
<code class="descname">_getElementsFrom</code><span class="sig-paren">(</span><em>smsTopList</em>, <em>dataset</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theoryPrediction.html#_getElementsFrom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theoryPrediction._getElementsFrom" title="Permalink to this definition">¶</a></dt>
<dd><p>Get elements that belong to any of the TxNames in dataset 
(appear in any of constraints in the result).    
Loop over all elements in smsTopList and returns a copy of the elements belonging
to any of the constraints (i.e. have efficiency != 0). The copied elements
have their weights multiplied by their respective efficiencies.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dataset</strong> &#8211; Data Set to be considered (DataSet object)</li>
<li><strong>smsTopList</strong> &#8211; list of topologies containing elements (TopologyList object)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">list of elements (Element objects)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="theory.theoryPrediction.TheoryPrediction">
<em class="property">class </em><code class="descname">TheoryPrediction</code><a class="reference internal" href="_modules/theory/theoryPrediction.html#TheoryPrediction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.theoryPrediction.TheoryPrediction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>An instance of this class represents the results of the theory prediction
for an analysis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>analysis</strong> &#8211; holds the analysis (ULanalysis or EManalysis object)
to which the prediction refers</li>
<li><strong>xsection</strong> &#8211; xsection of the theory prediction 
(relevant cross section to be compared with the experimental limits).
It is a XSection object.</li>
<li><strong>conditions</strong> &#8211; list of values for the analysis conditions
(only for upper limit-type analysis, e.g. analysis=ULanalysis)</li>
<li><strong>mass</strong> &#8211; mass of the cluster to which the theory prediction refers
(only for upper limit-type analysis, e.g. analysis=ULanalysis)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="theory.theoryPrediction.TheoryPrediction.computeStatistics">
<code class="descname">computeStatistics</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/theoryPrediction.html#TheoryPrediction.computeStatistics"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.theoryPrediction.TheoryPrediction.computeStatistics" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the likelihood, chi-square and expected upper limit for this theory prediction.
The resulting values are stored as the likelihood, chi2 and expectedUL attributes.</p>
</dd></dl>

<dl class="method">
<dt id="theory.theoryPrediction.TheoryPrediction.getmaxCondition">
<code class="descname">getmaxCondition</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/theoryPrediction.html#TheoryPrediction.getmaxCondition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.theoryPrediction.TheoryPrediction.getmaxCondition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the maximum xsection from the list conditions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">maximum condition xsection (float)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="theory.theoryPrediction.TheoryPredictionList">
<em class="property">class </em><code class="descname">TheoryPredictionList</code><span class="sig-paren">(</span><em>theoryPredictions=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/theoryPrediction.html#TheoryPredictionList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.theoryPrediction.TheoryPredictionList" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>An instance of this class represents a collection of theory prediction
objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><strong>_theoryPredictions</strong> &#8211; list of TheoryPrediction objects</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="theory.theoryPrediction.theoryPredictionsFor">
<code class="descname">theoryPredictionsFor</code><span class="sig-paren">(</span><em>expResult</em>, <em>smsTopList</em>, <em>maxMassDist=0.2</em>, <em>useBestDataset=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/theoryPrediction.html#theoryPredictionsFor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.theoryPrediction.theoryPredictionsFor" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute theory predictions for the given experimental result, using the list of elements
in smsTopList.
For each Txname appearing in expResult, it collects the elements and efficiencies, 
combine the masses (if needed) and compute the conditions (if existing).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>expResult</strong> &#8211; expResult to be considered (ExpResult object)</li>
<li><strong>smsTopList</strong> &#8211; list of topologies containing elements (TopologyList object)</li>
<li><strong>maxMassDist</strong> &#8211; maximum mass distance for clustering elements (float)</li>
<li><strong>useBestDataset</strong> &#8211; If True, uses only the best dataset (signal region).
If False, returns predictions for all datasets.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a TheoryPredictionList object containing a list of TheoryPrediction objects</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-theory.topology">
<span id="theory-topology-module"></span><h2>theory.topology module<a class="headerlink" href="#module-theory.topology" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-topology"></span><dl class="class">
<dt id="theory.topology.Topology">
<em class="property">class </em><code class="descname">Topology</code><span class="sig-paren">(</span><em>elements=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/topology.html#Topology"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.topology.Topology" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>An instance of this class represents a topology.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>vertnumb</strong> &#8211; list with number of vertices in each branch</li>
<li><strong>verparts</strong> &#8211; list with number of final states in each branch</li>
<li><strong>elementList</strong> &#8211; list of Element objects with this common topology</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="theory.topology.Topology.addElement">
<code class="descname">addElement</code><span class="sig-paren">(</span><em>newelement</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/topology.html#Topology.addElement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.topology.Topology.addElement" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an Element object to the elementList.</p>
<p>For all the pre-existing elements, which match the new element, add
weight. If no pre-existing elements match the new one, add it to the
list. OBS: newelement MUST ALREADY BE SORTED (see element.sort())</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>newelement</strong> &#8211; element to be added (Element object)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True, if the element was added. False, otherwise</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.topology.Topology.checkConsistency">
<code class="descname">checkConsistency</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/topology.html#Topology.checkConsistency"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.topology.Topology.checkConsistency" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the all the elements in elementList are
consistent with the topology (same number of vertices and final states)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True if all the elements are consistent. Print error message
and exits otherwise.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.topology.Topology.describe">
<code class="descname">describe</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/topology.html#Topology.describe"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.topology.Topology.describe" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a detailed description of the topology.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list of strings with a description of the topology</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.topology.Topology.getElements">
<code class="descname">getElements</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/topology.html#Topology.getElements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.topology.Topology.getElements" title="Permalink to this definition">¶</a></dt>
<dd><p>Get list of elements of the topology.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">elementList (list of Element objects)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.topology.Topology.getTotalWeight">
<code class="descname">getTotalWeight</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/topology.html#Topology.getTotalWeight"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.topology.Topology.getTotalWeight" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of all elements weights.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">sum of weights of all elements (XSection object)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="theory.topology.TopologyList">
<em class="property">class </em><code class="descname">TopologyList</code><span class="sig-paren">(</span><em>topologies=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/topology.html#TopologyList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.topology.TopologyList" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>An instance of this class represents an iterable collection of topologies.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><strong>topos</strong> &#8211; list of topologies (Topology objects)</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="theory.topology.TopologyList.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>newTopology</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/topology.html#TopologyList.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.topology.TopologyList.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if elements in newTopology matches an entry in self.topos.</p>
<p>If it does, add weight. If the same topology exists, but not the same
element, add element. If neither element nor topology exist, add the
new topology and all its elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>newTopology</strong> &#8211; Topology object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.topology.TopologyList.addElement">
<code class="descname">addElement</code><span class="sig-paren">(</span><em>newelement</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/topology.html#TopologyList.addElement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.topology.TopologyList.addElement" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an Element object to the corresponding topology in the list.
If the element topology does not match any of the topologies in
the list, create a new topology and insert it in the list.
If the element topology already exists, add it to the respective
topology.        
:parameter newelement: element to be added (Element object)
:returns: True, if the element was added. False, otherwise</p>
</dd></dl>

<dl class="method">
<dt id="theory.topology.TopologyList.addList">
<code class="descname">addList</code><span class="sig-paren">(</span><em>topoList</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/topology.html#TopologyList.addList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.topology.TopologyList.addList" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds topologies in topoList using the add method.</p>
</dd></dl>

<dl class="method">
<dt id="theory.topology.TopologyList.describe">
<code class="descname">describe</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/topology.html#TopologyList.describe"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.topology.TopologyList.describe" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns string with basic information about the topology list.</p>
</dd></dl>

<dl class="method">
<dt id="theory.topology.TopologyList.getElements">
<code class="descname">getElements</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/topology.html#TopologyList.getElements"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.topology.TopologyList.getElements" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list with all the elements in all the topologies.</p>
</dd></dl>

<dl class="method">
<dt id="theory.topology.TopologyList.getTotalWeight">
<code class="descname">getTotalWeight</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/topology.html#TopologyList.getTotalWeight"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.topology.TopologyList.getTotalWeight" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of all topologies total weights.</p>
</dd></dl>

<dl class="method">
<dt id="theory.topology.TopologyList.index">
<code class="descname">index</code><span class="sig-paren">(</span><em>topo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/topology.html#TopologyList.index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.topology.TopologyList.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses bisect to find the index where of topo in the list.
If topo does not appear in the list, returns None.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>topo</strong> &#8211; Topology object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">position of topo in the list. If topo does not    
appear in the list, return None.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="theory.topology.TopologyList.insert">
<code class="descname">insert</code><span class="sig-paren">(</span><em>index</em>, <em>topo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/theory/topology.html#TopologyList.insert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#theory.topology.TopologyList.insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-theory">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-theory" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-theory.__init__"></span></div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="experiment.html" class="btn btn-neutral float-right" title="experiment package" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="SModelS Code Documentation" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, &lt;function authors at 0x7f73f74eb500&gt;.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.1.0patch1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>